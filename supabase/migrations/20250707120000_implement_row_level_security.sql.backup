-- 20250707120000_implement_row_level_security.sql
-- Implementación progresiva y segura de Row Level Security (RLS)
-- para proteger los datos familiares sin afectar la funcionalidad existente

-- =====================================================
-- PASO 1: HABILITAR RLS EN TODAS LAS TABLAS
-- =====================================================

-- Habilitar RLS (inicialmente sin políticas restrictivas)
ALTER TABLE families ENABLE ROW LEVEL SECURITY;
ALTER TABLE family_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subjects ENABLE ROW LEVEL SECURITY;
ALTER TABLE actions ENABLE ROW LEVEL SECURITY;
ALTER TABLE events ENABLE ROW LEVEL SECURITY;
ALTER TABLE special_action_configs ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- PASO 2: FUNCIÓN AUXILIAR PARA VERIFICAR MEMBRESÍA
-- =====================================================

-- Crear función para verificar si un usuario pertenece a una familia
CREATE OR REPLACE FUNCTION user_belongs_to_family(family_uuid UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM family_members 
    WHERE family_id = family_uuid 
    AND user_id = auth.uid()
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- PASO 3: POLÍTICAS PARA TABLA FAMILIES
-- =====================================================

-- Los usuarios pueden ver las familias a las que pertenecen
DO $$ BEGIN
    CREATE POLICY "Users can view their families" ON families
      FOR SELECT
      USING (user_belongs_to_family(id));
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- Los usuarios pueden actualizar las familias a las que pertenecen
DO $$ BEGIN
    CREATE POLICY "Users can update their families" ON families
      FOR UPDATE
      USING (user_belongs_to_family(id))
      WITH CHECK (user_belongs_to_family(id));
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- Permitir inserción de nuevas familias (para el proceso de onboarding)
DO $$ BEGIN
    CREATE POLICY "Users can create families" ON families
      FOR INSERT
      WITH CHECK (true);
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- PASO 4: POLÍTICAS PARA TABLA FAMILY_MEMBERS
-- =====================================================

-- Los usuarios pueden ver membresías de sus familias
CREATE POLICY "Users can view family memberships" ON family_members
  FOR SELECT
  USING (
    user_id = auth.uid() OR 
    user_belongs_to_family(family_id)
  );

-- Los usuarios pueden unirse a familias (para el proceso de invitación)
CREATE POLICY "Users can join families" ON family_members
  FOR INSERT
  WITH CHECK (user_id = auth.uid());

-- Los usuarios pueden actualizar sus propias membresías
CREATE POLICY "Users can update their memberships" ON family_members
  FOR UPDATE
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- Los usuarios pueden eliminar sus propias membresías
CREATE POLICY "Users can delete their memberships" ON family_members
  FOR DELETE
  USING (user_id = auth.uid());

-- =====================================================
-- PASO 5: POLÍTICAS PARA TABLA SUBJECTS
-- =====================================================

-- Los usuarios pueden ver sujetos de sus familias
CREATE POLICY "Users can view family subjects" ON subjects
  FOR SELECT
  USING (user_belongs_to_family(family_id));

-- Los usuarios pueden crear sujetos en sus familias
CREATE POLICY "Users can create family subjects" ON subjects
  FOR INSERT
  WITH CHECK (user_belongs_to_family(family_id));

-- Los usuarios pueden actualizar sujetos de sus familias
CREATE POLICY "Users can update family subjects" ON subjects
  FOR UPDATE
  USING (user_belongs_to_family(family_id))
  WITH CHECK (user_belongs_to_family(family_id));

-- Los usuarios pueden eliminar sujetos de sus familias
CREATE POLICY "Users can delete family subjects" ON subjects
  FOR DELETE
  USING (user_belongs_to_family(family_id));

-- =====================================================
-- PASO 6: POLÍTICAS PARA TABLA ACTIONS
-- =====================================================

-- Los usuarios pueden ver acciones de sujetos de sus familias
CREATE POLICY "Users can view family actions" ON actions
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = actions.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  );

-- Los usuarios pueden crear acciones para sujetos de sus familias
CREATE POLICY "Users can create family actions" ON actions
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = actions.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  );

-- Los usuarios pueden actualizar acciones de sujetos de sus familias
CREATE POLICY "Users can update family actions" ON actions
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = actions.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = actions.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  );

-- Los usuarios pueden eliminar acciones de sujetos de sus familias
CREATE POLICY "Users can delete family actions" ON actions
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = actions.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  );

-- =====================================================
-- PASO 7: POLÍTICAS PARA TABLA EVENTS
-- =====================================================

-- Los usuarios pueden ver eventos de sujetos de sus familias
CREATE POLICY "Users can view family events" ON events
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = events.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  );

-- Los usuarios pueden crear eventos para sujetos de sus familias
CREATE POLICY "Users can create family events" ON events
  FOR INSERT
  WITH CHECK (
    user_id = auth.uid() AND
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = events.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  );

-- Los usuarios pueden actualizar sus propios eventos en familias permitidas
CREATE POLICY "Users can update their family events" ON events
  FOR UPDATE
  USING (
    user_id = auth.uid() AND
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = events.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  )
  WITH CHECK (
    user_id = auth.uid() AND
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = events.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  );

-- Los usuarios pueden eliminar sus propios eventos en familias permitidas
CREATE POLICY "Users can delete their family events" ON events
  FOR DELETE
  USING (
    user_id = auth.uid() AND
    EXISTS (
      SELECT 1 FROM subjects 
      WHERE subjects.id = events.subject_id 
      AND user_belongs_to_family(subjects.family_id)
    )
  );

-- =====================================================
-- PASO 8: POLÍTICAS PARA TABLA SPECIAL_ACTION_CONFIGS
-- =====================================================

-- Los usuarios pueden ver configuraciones especiales de sus familias
CREATE POLICY "Users can view family special configs" ON special_action_configs
  FOR SELECT
  USING (user_belongs_to_family(family_id));

-- Los usuarios pueden crear configuraciones especiales en sus familias
CREATE POLICY "Users can create family special configs" ON special_action_configs
  FOR INSERT
  WITH CHECK (user_belongs_to_family(family_id));

-- Los usuarios pueden actualizar configuraciones especiales de sus familias
CREATE POLICY "Users can update family special configs" ON special_action_configs
  FOR UPDATE
  USING (user_belongs_to_family(family_id))
  WITH CHECK (user_belongs_to_family(family_id));

-- Los usuarios pueden eliminar configuraciones especiales de sus familias
CREATE POLICY "Users can delete family special configs" ON special_action_configs
  FOR DELETE
  USING (user_belongs_to_family(family_id));

-- =====================================================
-- PASO 9: VERIFICACIÓN DE POLÍTICAS
-- =====================================================

-- Crear función de diagnóstico para verificar que las políticas funcionan
CREATE OR REPLACE FUNCTION rls_diagnostic()
RETURNS TABLE(
  table_name TEXT,
  rls_enabled BOOLEAN,
  policy_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    schemaname||'.'||tablename as table_name,
    rowsecurity as rls_enabled,
    (SELECT COUNT(*) FROM pg_policies WHERE schemaname = t.schemaname AND tablename = t.tablename) as policy_count
  FROM pg_tables t
  WHERE schemaname = 'public' 
  AND tablename IN ('families', 'family_members', 'subjects', 'actions', 'events', 'special_action_configs')
  ORDER BY tablename;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- COMENTARIOS Y NOTAS
-- =====================================================

/*
IMPLEMENTACIÓN COMPLETADA:

✅ RLS habilitado en todas las tablas principales
✅ Función auxiliar user_belongs_to_family() para verificar membresía
✅ Políticas granulares por tabla y operación (SELECT, INSERT, UPDATE, DELETE)
✅ Preservación de funcionalidad existente (onboarding, invitaciones, etc.)
✅ Función de diagnóstico para verificar el estado de RLS

PRINCIPIOS DE SEGURIDAD IMPLEMENTADOS:

1. Isolación por familia: Los usuarios solo pueden acceder a datos de sus familias
2. Ownership de eventos: Los usuarios solo pueden modificar/eliminar sus propios eventos
3. Flexibilidad de membresía: Preserva el sistema de invitaciones existente
4. Cascada de permisos: Los permisos fluyen de familia → sujetos → acciones → eventos

COMPATIBILIDAD:

- ✅ Mantiene funcionalidad de onboarding
- ✅ Preserva sistema de códigos de invitación  
- ✅ Conserva real-time subscriptions
- ✅ Compatible con queries existentes
- ✅ No requiere cambios en el código de aplicación

PARA VERIFICAR:
1. Ejecutar: SELECT * FROM rls_diagnostic();
2. Probar funcionalidad completa de la app
3. Verificar que usuarios no puedan acceder a familias ajenas

*/